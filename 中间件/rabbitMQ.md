#### 消息中间件概述

##### 	什么是消息中间件

MQ：全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法

原先：ip:port/order/add?goodsId=1

![](https://www.ydlclass.com/doc21xnv/assets/image-20220408204615842-2ec9d620.png)

现在：异步调用

![](https://www.ydlclass.com/doc21xnv/assets/image-20220408205148101-2172857b.png)

为什么使用MQ

​	在项目中，可将一些无需即时返回且耗时的操作提取出来，进行**异步处理**，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而**提高**了**系统**的**吞吐量**。

MQ优势

应用解耦：MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。

![](https://www.ydlclass.com/doc21xnv/assets/image-20220408210051290-27a1c5bb.png)

异步提速：将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。

![](https://www.ydlclass.com/doc21xnv/assets/image-20220408210805836-3b12b167.png)

削峰填谷

- 如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。
- 消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了。
- 使用了MQ之后，限制消费消息的速度为1000，但是这样一来，高峰期产生的数据势必会被积压在MQ中，高峰就被“削”掉了。但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000QPS，直到消费完积压的消息,这就叫做“填谷”


![](https://www.ydlclass.com/doc21xnv/assets/image-20220408211341420-1d296a5c.png)

MQ劣势

- 系统可用性降低：系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？
- 系统复杂度提高：MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？
- 一致性问题：A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性。

什么时候用MQ

- 生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。
-  容许短暂的不一致性。
-  确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。

##### 	AMQP和JMS

- AMQP：一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。

- JMS：Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。

区别

- JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式
- JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。
- JMS规定了两种消息模式；而AMQP的消息模式更加丰富

##### 	消息队列产品

- ActiveMQ：基于JMS
- ZeroMQ：基于C语言开发
- RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好
- RocketMQ：基于JMS，阿里巴巴产品
- Kafka：类似MQ的产品；分布式消息系统，高吞吐量

![](https://www.ydlclass.com/doc21xnv/assets/image-20200320111345727-041941a7.png)

##### 	RabbitMQ

特点

- 使用简单，功能强大。
- 基于**AMQP**协议。 跨语言 c node.js->mq->java python
- 社区活跃，文档完善。
- 高并发性能好，这主要得益于**Erlang**语言。 c 底层语言，性能强。java 好开发。构建一个web。
- Spring Boot默认已集成RabbitMQ

工作模式

简单模式、work模式、Publish/Subscribe发布与订阅模式、**Routing**路由模式、**Topics**主题模式、RPC远程调用模式

#### RabbitMQ工作原理

![](https://www.ydlclass.com/doc21xnv/assets/image-20200320180217097-f868c655.png)

一个消费者监听一个队列

- Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。
- Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。
- Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。
- Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。
- Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。

发送消息

1. 生产者和Broker建立长连接。
2. 生产者和Broker建立通道。
3. 生产者通过通道消息发送给Broker，由Exchange将消息进行转发。
4. Exchange将消息转发到指定的Queue（队列）

接受消息

1. 消费者和Broker建立TCP连接
2. 消费者和Broker建立通道
3. 消费者监听指定的Queue（队列）
4. 当有消息到达Queue时Broker默认将消息推送给消费者。
5. 消费者接收到消息。

