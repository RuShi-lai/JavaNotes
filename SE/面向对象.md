#### **面向对象和面向过程**

1. 面向过程：分析实现的步骤，通过函数依次调用实现。
2. 面向对象：整个需求按照特点、功能划分，将这些存在共性的部分**封装成类**（类实例化后才是对象），让对象去解决对应的问题。

#### 封装

#### 	return关键字

1. 终止当前方法继续执行
2. 返回方法的返回值

##### 	方法重载

1. 方法名必须一致
2. 参数不一致，有两层含义第一是参数的数量不一致，第二层含义是：参数的类型不一致，【参数的名字一样不一样都行】。
3. 返回值无要求

#####   	包命名：域名倒置命名包

##### 	权限修饰符（同package、当前类、子孙类、其他package）

1. public  ：都可以
2. protected：其他package不行
3. private：只能同package
4. 默认：同package和当前类
5. class只能public修饰
6. 内部类可以被public、protected、private修饰
7. 局部变量不能用修饰符修饰

##### 	创建对象

1. 在堆区分配对象需要的内存。
2. 对所有实例变量赋默认值。
3. 执行构造方法（方法区内，调用时间对象创建时），比如我们可以使用构造方法赋值

4. 在栈区定义引用变量，然后将堆区对象的地址赋值给它。

##### 	this

1. 每个方法都会默认传入一个变量叫this，它永远指向调用它的【当前实例】。
2. this作构造器只能放第一行

​	String

1. 符串查找： indexOf    contains
2. 字符串替换：replace(old,new) /replaceAll(old,new)、 replaceFirst(old,new) 
3. 字符串分割：split(c)
4. 字符串截串：substring(beginIndex,length)
5. 大小写转换：toUpperCase()、toLowerCase()

##### 	包装类型易错

```java
public static void main(String[] args) {
    Integer num2 = 128;
    Integer num1 = 128;
    System.out.println(num1 == num2); //两个不同对象啊
}
false
```

#### 继承（是 is-a关系 ）  dog is an animal

##### 	super

1. 作用：指向父类实例的引用
2. 在子类的成员方法中，访问父类的成员方法、成员变量。
3. 在子类的构造方法中，访问父类的构造方法。
4. super构造器只能放在第一行，父类没有构造，获取不到属性
5. - 总结
   - 子类在构造的时候，一定会构造一个父类，默认调用父类的无参构造器。
   - 子类最多只能继承一个父类(指直接继承)， java 中是单继承机制，我们可以使用连续继承来实现。

##### 方法重写（覆写）

1. 范围：父类
2. 方法名：一致
3. 形参列表必须相同
4. 返回类型：一样或者子类的返回值是父类的返回值的子类
5. 权限修饰符：子类不能缩小父类的访问权限

##### Object祖先类

1. boolean equals(Objec obj)

2. int hashCode() 返回值其实是实例对象运行时的内存地址。

   1. 常见算法：MD5、SHA1、SHA256、SHA512 

      ```java
       MessageDigest md5 = MessageDigest.getInstance("MD5");
              byte[] digest = md5.digest("123".getBytes());
              System.out.println(Arrays.toString(digest));
      ```

3. toString()、getClass()、notify()唤醒线程、notifyAll()、wait()-(long timeout)-((long timeout, int nanos)阻塞当前线程、finalize()垃圾回收

4. clone()浅拷贝

   1. 克隆就是在内存里边赋值一个实例对象。但是Object的克隆方法只能浅拷贝。同时必须实现Cloneable接口。

   2. 浅拷贝：只拷贝了值，引用类型只是进行引用传递

   3. 深拷贝：不仅拷贝了值、并创建了新的对象，完全复制其成员变量

      ​

#### 多态

##### 底层原理

1. ##### 字节码分析	

   1. ```
      Animal animal = Math.random() > 0.5 ? new Dog():new Cat(); 
      //左侧animal为编译类型（静态类型），右侧为运行时类型（实际类型）
      ```

   2. 静态类型：jvm在编译的时候就能确定具体调用哪个版本的方法，字节码指令执行时直接调用即可

   3. 动态类型：必须等待运行时才能确定类型，与此同时才能同步开展选择方法版本的工作，这个运行时才选择方法调用版本的行为称之为【虚方法分派】。

   4. 常量池：常量池是我们的资源仓库，里边保存了大量的符号引用（就是的你给类、方法、变量的名字），这些符号引用有一部分会在类加载阶段或者第一次使用的时候就被转化为【直接引用】，这种转化叫做【静态解析】，另一部分会在运行期间转化为【直接引用】，这一部分称之为【动态链接】。

   5. 虚拟机在选择重载方式时，是通过【静态类型】决定的而不是动态类型。由于静态类型编译时就可知，事实上虚拟在编译期就已经知道选择哪一个重载方法

   6. ```java
      public class Main {
          public static void main(String[] args) {
              Party party = new Party();
              Human human = new Human();
              party.play(human);
              Human man = new Man();
              party.play(man);
              Human woman = new Woman();
              party.play(woman);
          }
      }
      class Party {
          public void play(Human human){ System.out.println("人类的狂欢！");}
          public void play(Man man){System.out.println("男人的狂欢！");}
          public void play(Woman woman){System.out.println("女人的狂欢！");}

      }
      class Human {}
      class Man extends Human{}
      class Woman extends Human{}//三次都是人类的狂欢   原因看6
      ```

   7. 重写方法的调用时依据运行时的类型决定的。

      ​

##### 对象的转型

1. 向上转型：子类对象转为父类，向上转型不需要显示的转化。 Father Father = son；向上转型会丢失子类独有的特性

   1. 向上转型会丢失Dog的特性：

      静态分派是根据静态类型选择对应的版本，向上转型了后静态分派的过程只能在Animal这个类型查找方法，所以dog的特有方法就丢失了。

      动态分派的过程还是依靠运行时类型决定的所以调用的方法还是Dog类的。

      也由此得出一个结论，一个对象能调用的方法由它的【静态类型】决定。


2. 向下转型：父类对象转为子类，向下转型需要强制转化。 Son son = （Son）Father；向下转型可能会出现错误，需要谨慎。

##### 抽象方法	

1. 抽象方法不能实例化（new），需要依靠子类采用向上转型的方式处理；
2. 抽象类只有在构建子类的时候才会被构建出实例。

##### 设计模式

1. 开闭原则：对扩展开发、对修改关闭。通过抽象约束、封装变化来实现
2. ​里式代换原则： 继承必须确保超类所拥有的性质在子类中仍然成立。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
3. 依赖倒转原则：要面向接口编程，不要面向实现编程。
   1. 每个类尽量提供接口或抽象类，或者两者都具备。
   2. 变量的声明类型尽量是接口或者是抽象类。
   3. 任何类都不应该从具体类派生。
   4. 使用继承时尽量遵循里氏替换原则
4. 接口隔离原则：尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。
5. 迪米特法则：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。
6. 合成复用法则：尽量使用合成/聚合的方式，而不是使用继承。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范
7. 单一原则：一个类只做一件事

模板方法设计模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类【行为型模式】。

优点：

1. 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
2. 它在父类中提取了公共的部分代码，便于【代码复用】。
3. 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。

缺点：

1. 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
2. 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
3. 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。

策略设计模式：比较成员变量，按一定方式排序（优点：只需要改接口）

1. User不变
2. 写一个比较器的接口
3. 写一个比较器

4. 写一个工具类专门给User排序

5. 排序开始


#### 面向对象其他知识

##### 	代码块

1. 代码块又称初始化块，属于类中的成员，它是讲逻辑语句封装在方法体中，通过{} 包裹。代码块没有方法名，没有参数，没有返回值，只有方法体，而且不通过对象或类进行显示的调用，他会在类加载，或者创建对象时主动的隐式调用。
2. 静态代码块：一个类被加载时会被调用一次，常用在需要做一些全局初始化的工作。
3. 实例代码块：每次创建实例，都会被调用 一次，其实用的很少
4. 顺序：父类的静态代码块  > 子类的静态代码块 >父类的实例代码块>父类的构造器>子类的实例代码块>子类的构造器

##### 单例设计模式

1. 一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。

2. 思路

   （1）别人不能new实例，所以要将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。

   （2）在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。

   （3）定义一个静态方法返回这个唯一对象。

3. 饿汉式：立即加载就是使用类的时候已经将对象创建完毕（不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故又被称为“饿汉模式”），常见的实现办法就是直接new实例化。

   ```java
   public class Singleton {
       // 将自身实例化对象设置为一个属性，并用static、final修饰
       private static final Singleton instance = new Singleton();
       // 构造方法私有化
       private Singleton() {}
       // 静态方法返回该实例
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

4. 懒汉式：延迟加载就是调用get()方法时实例才被创建（先不急着实例化出对象，等要用的时候才给你创建出来。不着急，故又称为“懒汉模式”），常见的实现方法就是在get方法中进行new实例化。

   ```java
   public class Singleton {
       //多线程错误
       // 将自身实例化对象设置为一个属性，并用static修饰
       private static Singleton instance;
       // 构造方法私有化
       private Singleton() {}
       // 静态方法返回该实例
       public static Singleton getInstance() {
           if(instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   public class Singleton {
     //可用于多线程
       /** 私有化构造器 */
       private Singleton() {
       }
       /** 对外提供公共的访问方法 */
       public static Singleton getInstance() {
           return SingletonHolder.INSTANCE;
       }
       /** 写一个静态内部类，里面实例化外部类 */
       private static class SingletonHolder {
           private static final Singleton INSTANCE = new Singleton();
       }

   }
   ```

##### 	匿名内部类

1. 实现接口的匿名类
2. 匿名子类（继承父类）

​	箭头函数

如果一个接口只有一个抽象方法，那么这个接口也称之为函数式接口。可以使用@FunctionalInterface注解标识。

```java
@FunctionalInterface
public interface Function {
    int plus(int i,int j);
}
/////////////////////////////////////////////////////////////////
public class Main {
    public static void test(Function function){
        System.out.println(function.plus(1, 2));
    }
    public static void main(String[] args) {
        test((i,j) -> {return i + j;});
      //如果方法体只有一行代码可以简化 {}中为方法体
         test((i,j) -> i + j);
    }
}

```

##### 引用传递

```java
changeInt(Dog d){
	d = new Dog("tom");}
Dog dog = new Dog("jerry");
changeInt(dog);
System.out.println(dog.getName());
//结果：jerry  调用changeInt(dog)方法，也不是将【dog】传入方法，而是将dog的引用地址值（0x123FE222）拷贝一份赋值给形参【d】，名字一样不一样都无所谓，当d = new Dog("tom");执行时，形参会开辟新空间，指向新对象，外部的【dog】不受影响。
```



#### 应知应会的JVM

##### 编译

1. java不是编译成具体的【机器指令】，因为不同的硬件结构和操作系统有不同的机器指令，java为了实现【一次编写、随处运行】的目标，实际上编译出的指令是【字节码】，字节码只能由jvm识别，我们的硬件是无法识别的，运行的过程却是由jvm使用解释的方式执行。

2. 编译器

   1. 前端编译器，最常见的就是我们的 javac 编译器，其将 Java 源代码编译为 Java 字节码文件

   2. JIT 即时编译器，最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将 Java 字节码编译为本地机器代码。

      吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。

   3. AOT 编译器则能将源代码直接编译为本地机器码。

      内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化。

3. 静态类型语言：变量定义时有类型声明的语言（编译器就可以确定运行时需要的内存总量）

   1. 变量的类型在编译的时候确定
   2. 变量的类型在运行时不能修改

4. 动态类型语言：变量定义时无类型声明的语言

   1. 变量的类型在运行的时候确定

   2. 变量的类型在运行可以修改


5. 强类型定义语言：一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。强类型定义语言是类型安全的语言。

6. 弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。
   ​

   ​

   ​



#### 55







子类在构造的时候，一定会构造一个父类，默认调用父类的无参构造器。

#### 

